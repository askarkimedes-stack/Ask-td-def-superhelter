<!DOCTYPE html>
<html lang="no">
<head>
    <meta charset="UTF-8">
    <title>Superhelt TD - Svingete Vei</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2c3e50;
            color: white;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            display: flex;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        canvas {
            background: #27ae60;
            cursor: crosshair;
            display: block;
        }

        /* Meny p친 h칮yre side */
        #sidebar {
            width: 200px;
            background: #34495e;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            border-left: 5px solid #2c3e50;
        }

        h2 { margin-top: 0; font-size: 18px; text-align: center; color: #f1c40f; }
        
        .stats {
            background: #2c3e50;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .hero-btn {
            background: #ecf0f1;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition: 0.2s;
            color: #2c3e50;
        }

        .hero-btn:hover { background: #bdc3c7; }
        .hero-btn.active { border: 3px solid #f1c40f; background: #fff; }

        .hero-icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin-bottom: 5px;
            border: 2px solid #333;
        }

        .cost { font-weight: bold; font-size: 12px; color: #e74c3c; }
        .desc { font-size: 11px; color: #7f8c8d; text-align: center; }

    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    
    <div id="sidebar">
        <h2>Kontrollpanel</h2>
        <div class="stats">
            <div>游눯 Gull: <span id="gold">150</span></div>
            <div style="margin-top:5px;">仇벒잺 Liv: <span id="lives">20</span></div>
        </div>

        <button class="hero-btn active" onclick="selectHero('laser')">
            <div class="hero-icon" style="background: #e74c3c;"></div>
            <span>Laser Helt</span>
            <span class="cost">50 Gull</span>
            <span class="desc">Rask skyting, treffer 1 fiende.</span>
        </button>

        <button class="hero-btn" onclick="selectHero('boomerang')">
            <div class="hero-icon" style="background: #9b59b6;"></div>
            <span>Boomerang</span>
            <span class="cost">100 Gull</span>
            <span class="desc">Kaster v친pen som kommer tilbake og treffer alle.</span>
        </button>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const goldEl = document.getElementById('gold');
const livesEl = document.getElementById('lives');
const buttons = document.querySelectorAll('.hero-btn');

// Spillvariabler
let gold = 150;
let lives = 20;
let selectedType = 'laser'; // Standard valg
let frameCount = 0;

const heroes = [];
const enemies = [];
const projectiles = [];

// Definer en svingete vei (waypoints)
const waypoints = [
    {x: 0, y: 100},
    {x: 700, y: 100},
    {x: 700, y: 300},
    {x: 100, y: 300},
    {x: 100, y: 500},
    {x: 800, y: 500}
];

// Menyvalg funksjon
window.selectHero = function(type) {
    selectedType = type;
    buttons.forEach(btn => btn.classList.remove('active'));
    // Finn knappen som ble trykket (enkel logikk for demo)
    if(type === 'laser') buttons[0].classList.add('active');
    else buttons[1].classList.add('active');
};

// Tegn veien
function drawPath() {
    ctx.beginPath();
    ctx.lineWidth = 40;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.strokeStyle = '#95a5a6';
    
    ctx.moveTo(waypoints[0].x, waypoints[0].y);
    for (let i = 1; i < waypoints.length; i++) {
        ctx.lineTo(waypoints[i].x, waypoints[i].y);
    }
    ctx.stroke();

    // Tegn en tynn linje i midten for 친 se ruten
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#7f8c8d';
    ctx.stroke();
}

// KLASSER

class Hero {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.cooldown = 0;
        
        if (type === 'laser') {
            this.range = 150;
            this.color = '#e74c3c';
            this.cost = 50;
            this.fireRate = 40; 
        } else if (type === 'boomerang') {
            this.range = 180;
            this.color = '#9b59b6';
            this.cost = 100;
            this.fireRate = 90; // Skyter tregere
        }
    }

    draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // Kappe
        ctx.fillStyle = '#f1c40f';
        ctx.fillRect(this.x - 10, this.y + 5, 20, 10);
    }

    update() {
        if (this.cooldown > 0) this.cooldown--;

        // Finn n칝rmeste fiende
        let target = null;
        for (let enemy of enemies) {
            let dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
            if (dist < this.range) {
                target = enemy;
                break; // Skyt p친 den f칮rste vi finner (oftest den som kom f칮rst)
            }
        }

        if (target && this.cooldown <= 0) {
            projectiles.push(new Projectile(this.x, this.y, target, this.type, this));
            this.cooldown = this.fireRate;
        }
    }
}

class Enemy {
    constructor() {
        this.wpIndex = 0; // Hvilket waypoint g친r vi mot
        this.x = waypoints[0].x;
        this.y = waypoints[0].y;
        this.speed = 1 + Math.random(); // Variert fart
        this.radius = 12;
        this.health = 5 + Math.floor(frameCount / 1000); // Blir vanskeligere over tid
        this.maxHealth = this.health;
    }

    draw() {
        ctx.fillStyle = '#2c3e50';
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        // Helsebar
        ctx.fillStyle = 'red';
        ctx.fillRect(this.x - 10, this.y - 20, 20, 4);
        ctx.fillStyle = '#2ecc71';
        ctx.fillRect(this.x - 10, this.y - 20, 20 * (this.health / this.maxHealth), 4);
    }

    update() {
        // Logikk for 친 f칮lge veien
        let target = waypoints[this.wpIndex + 1];
        if (!target) return; // Ferdig med veien

        let dx = target.x - this.x;
        let dy = target.y - this.y;
        let dist = Math.hypot(dx, dy);

        if (dist < 5) {
            this.wpIndex++; // N친dde punktet, g친 til neste
        } else {
            // Normaliser og flytt
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
        }
    }
}

class Projectile {
    constructor(x, y, target, type, owner) {
        this.x = x;
        this.y = y;
        this.startX = x;
        this.startY = y;
        this.target = target;
        this.type = type;
        this.owner = owner; // Hvem skj칮t?
        this.active = true;
        this.hitList = []; // For boomerang: husk hvem vi har truffet s친 vi ikke treffer samme 100 ganger
        
        if (type === 'laser') {
            this.speed = 8;
            this.damage = 2;
        } else {
            // Boomerang stats
            this.speed = 5;
            this.damage = 3;
            this.returning = false; // Er den p친 vei tilbake?
            this.maxDist = 200; // Hvor langt ut den flyr
            
            // Beregn vinkel mot m친let n친r den blir skutt
            let angle = Math.atan2(target.y - y, target.x - x);
            this.vx = Math.cos(angle) * this.speed;
            this.vy = Math.sin(angle) * this.speed;
        }
    }

    draw() {
        ctx.beginPath();
        if (this.type === 'laser') {
            ctx.fillStyle = '#e74c3c';
            ctx.arc(this.x, this.y, 4, 0, Math.PI * 2);
        } else {
            ctx.fillStyle = '#9b59b6';
            // Roterende effekt (visuell)
            let angle = frameCount * 0.5;
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(angle);
            ctx.fillRect(-6, -2, 12, 4);
            ctx.fillRect(-2, -6, 4, 12);
            ctx.restore();
            return; // Siden vi brukte restore, m친 vi unng친 fill() under
        }
        ctx.fill();
    }

    update() {
        if (this.type === 'laser') {
            // Enkel m친ls칮king
            let dx = this.target.x - this.x;
            let dy = this.target.y - this.y;
            let dist = Math.hypot(dx, dy);
            
            if (dist < 5 || this.target.health <= 0) {
                // Treff
                if(this.target.health > 0) this.target.health -= this.damage;
                this.active = false;
            } else {
                this.x += (dx / dist) * this.speed;
                this.y += (dy / dist) * this.speed;
            }

        } else if (this.type === 'boomerang') {
            // Boomerang logikk
            if (!this.returning) {
                this.x += this.vx;
                this.y += this.vy;
                
                // Sjekk avstand fra start
                let distFromStart = Math.hypot(this.x - this.startX, this.y - this.startY);
                if (distFromStart >= this.maxDist) {
                    this.returning = true;
                    this.hitList = []; // Reset hitlist p친 vei tilbake s친 den kan treffe igjen
                }
            } else {
                // Returner til eieren
                let dx = this.owner.x - this.x;
                let dy = this.owner.y - this.y;
                let dist = Math.hypot(dx, dy);
                
                if (dist < 10) {
                    this.active = false; // Fanget av helten
                } else {
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
            }

            // Kollisjon med ALLE fiender (piercing)
            enemies.forEach(enemy => {
                let dist = Math.hypot(enemy.x - this.x, enemy.y - this.y);
                if (dist < 20 && !this.hitList.includes(enemy)) {
                    enemy.health -= this.damage;
                    this.hitList.push(enemy);
                }
            });
        }
    }
}

// Mus-h친ndtering
canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    let cost = (selectedType === 'laser') ? 50 : 100;

    // Sjekk om vi klikker p친 stien (enkelt sjekk: er fargen gr친?)
    // For enkelhets skyld i koden, sjekker vi bare avstand til linjene
    let onPath = false;
    // (En avansert sjekk er utelatt for 친 holde koden kort, du kan plassere helter overalt unntatt opp친 hverandre)
    
    // Sjekk om opp친 annen helt
    let blocked = heroes.some(h => Math.hypot(h.x - x, h.y - y) < 30);

    if (!blocked && gold >= cost) {
        heroes.push(new Hero(x, y, selectedType));
        gold -= cost;
        goldEl.innerText = gold;
    } else if (gold < cost) {
        alert("Ikke nok gull!");
    }
});

// Hovedl칮kke
function animate() {
    frameCount++;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    drawPath();

    // Spawn fiender
    if (frameCount % 60 === 0) { // Hvert sekund ca
        enemies.push(new Enemy());
    }

    // Helter
    heroes.forEach(h => {
        h.update();
        h.draw();
    });

    // Fiender
    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        e.update();
        e.draw();

        // D칮d
        if (e.health <= 0) {
            enemies.splice(i, 1);
            gold += 15;
            goldEl.innerText = gold;
            continue;
        }

        // Kommet til m친l
        if (e.wpIndex >= waypoints.length - 1) {
            enemies.splice(i, 1);
            lives--;
            livesEl.innerText = lives;
            if (lives <= 0) {
                alert("Game Over!");
                location.reload();
            }
        }
    }

    // Prosjektiler
    for (let i = projectiles.length - 1; i >= 0; i--) {
        let p = projectiles[i];
        p.update();
        p.draw();
        if (!p.active) projectiles.splice(i, 1);
    }

    requestAnimationFrame(animate);
}

animate();

</script>
</body>
</html>
